{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.for-each.js\");\nrequire(\"core-js/modules/es.iterator.map.js\");\nrequire(\"core-js/modules/es.iterator.reduce.js\");\nconst http = require('http');\nconst https = require('https');\nconst xml2js = require('xml2js');\nconst url = require('url');\nconst fields = require('./fields');\nconst utils = require('./utils');\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml'\n};\nconst DEFAULT_MAX_REDIRECTS = 5;\nconst DEFAULT_TIMEOUT = 60000;\nclass Parser {\n  constructor(options = {}) {\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n  parseString(xml, callback) {\n    let prom = new Promise((resolve, reject) => {\n      this.xmlParser.parseString(xml, (err, result) => {\n        if (err) return reject(err);\n        if (!result) {\n          return reject(new Error('Unable to parse XML.'));\n        }\n        let feed = null;\n        if (result.feed) {\n          feed = this.buildAtomFeed(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n          feed = this.buildRSS2(result);\n        } else if (result['rdf:RDF']) {\n          feed = this.buildRSS1(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n          feed = this.buildRSS0_9(result);\n        } else if (result.rss && this.options.defaultRSS) {\n          switch (this.options.defaultRSS) {\n            case 0.9:\n              feed = this.buildRSS0_9(result);\n              break;\n            case 1:\n              feed = this.buildRSS1(result);\n              break;\n            case 2:\n              feed = this.buildRSS2(result);\n              break;\n            default:\n              return reject(new Error(\"default RSS version not recognized.\"));\n          }\n        } else {\n          return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"));\n        }\n        resolve(feed);\n      });\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n  parseURL(feedUrl, callback, redirectCount = 0) {\n    let xml = '';\n    let get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n    let urlParts = url.parse(feedUrl);\n    let headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n    let timeout = null;\n    let prom = new Promise((resolve, reject) => {\n      const requestOpts = Object.assign({\n        headers\n      }, urlParts, this.options.requestOptions);\n      let req = get(requestOpts, res => {\n        if (this.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n          if (redirectCount === this.options.maxRedirects) {\n            return reject(new Error(\"Too many redirects\"));\n          } else {\n            const newLocation = url.resolve(feedUrl, res.headers['location']);\n            return this.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n          }\n        } else if (res.statusCode >= 300) {\n          return reject(new Error(\"Status code \" + res.statusCode));\n        }\n        let encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n        res.setEncoding(encoding);\n        res.on('data', chunk => {\n          xml += chunk;\n        });\n        res.on('end', () => {\n          return this.parseString(xml).then(resolve, reject);\n        });\n      });\n      req.on('error', reject);\n      timeout = setTimeout(() => {\n        return reject(new Error(\"Request timed out after \" + this.options.timeout + \"ms\"));\n      }, this.options.timeout);\n    }).then(data => {\n      clearTimeout(timeout);\n      return Promise.resolve(data);\n    }, e => {\n      clearTimeout(timeout);\n      return Promise.reject(e);\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n  buildAtomFeed(xmlObj) {\n    let feed = {\n      items: []\n    };\n    utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n    if (xmlObj.feed.link) {\n      feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n      feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n    }\n    if (xmlObj.feed.title) {\n      let title = xmlObj.feed.title[0] || '';\n      if (title._) title = title._;\n      if (title) feed.title = title;\n    }\n    if (xmlObj.feed.updated) {\n      feed.lastBuildDate = xmlObj.feed.updated[0];\n    }\n    feed.items = (xmlObj.feed.entry || []).map(entry => this.parseItemAtom(entry));\n    return feed;\n  }\n  parseItemAtom(entry) {\n    let item = {};\n    utils.copyFromXML(entry, item, this.options.customFields.item);\n    if (entry.title) {\n      let title = entry.title[0] || '';\n      if (title._) title = title._;\n      if (title) item.title = title;\n    }\n    if (entry.link && entry.link.length) {\n      item.link = utils.getLink(entry.link, 'alternate', 0);\n    }\n    if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n    if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n    if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n    if (entry.content && entry.content.length) {\n      item.content = utils.getContent(entry.content[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n    if (entry.summary && entry.summary.length) {\n      item.summary = utils.getContent(entry.summary[0]);\n    }\n    if (entry.id) {\n      item.id = entry.id[0];\n    }\n    this.setISODate(item);\n    return item;\n  }\n  buildRSS0_9(xmlObj) {\n    var channel = xmlObj.rss.channel[0];\n    var items = channel.item;\n    return this.buildRSS(channel, items);\n  }\n  buildRSS1(xmlObj) {\n    xmlObj = xmlObj['rdf:RDF'];\n    let channel = xmlObj.channel[0];\n    let items = xmlObj.item;\n    return this.buildRSS(channel, items);\n  }\n  buildRSS2(xmlObj) {\n    let channel = xmlObj.rss.channel[0];\n    let items = channel.item;\n    let feed = this.buildRSS(channel, items);\n    if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n      this.decorateItunes(feed, channel);\n    }\n    return feed;\n  }\n  buildRSS(channel, items) {\n    items = items || [];\n    let feed = {\n      items: []\n    };\n    let feedFields = fields.feed.concat(this.options.customFields.feed);\n    let itemFields = fields.item.concat(this.options.customFields.item);\n    if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n      feed.feedUrl = channel['atom:link'][0].$.href;\n    }\n    if (channel.image && channel.image[0] && channel.image[0].url) {\n      feed.image = {};\n      let image = channel.image[0];\n      if (image.link) feed.image.link = image.link[0];\n      if (image.url) feed.image.url = image.url[0];\n      if (image.title) feed.image.title = image.title[0];\n      if (image.width) feed.image.width = image.width[0];\n      if (image.height) feed.image.height = image.height[0];\n    }\n    const paginationLinks = this.generatePaginationLinks(channel);\n    if (Object.keys(paginationLinks).length) {\n      feed.paginationLinks = paginationLinks;\n    }\n    utils.copyFromXML(channel, feed, feedFields);\n    feed.items = items.map(xmlItem => this.parseItemRss(xmlItem, itemFields));\n    return feed;\n  }\n  parseItemRss(xmlItem, itemFields) {\n    let item = {};\n    utils.copyFromXML(xmlItem, item, itemFields);\n    if (xmlItem.enclosure) {\n      item.enclosure = xmlItem.enclosure[0].$;\n    }\n    if (xmlItem.description) {\n      item.content = utils.getContent(xmlItem.description[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n    if (xmlItem.guid) {\n      item.guid = xmlItem.guid[0];\n      if (item.guid._) item.guid = item.guid._;\n    }\n    if (xmlItem.$ && xmlItem.$['rdf:about']) {\n      item['rdf:about'] = xmlItem.$['rdf:about'];\n    }\n    if (xmlItem.category) item.categories = xmlItem.category;\n    this.setISODate(item);\n    return item;\n  }\n\n  /**\n   * Add iTunes specific fields from XML to extracted JSON\n   *\n   * @access public\n   * @param {object} feed extracted\n   * @param {object} channel parsed XML\n   */\n  decorateItunes(feed, channel) {\n    let items = channel.item || [];\n    let categories = [];\n    feed.itunes = {};\n    if (channel['itunes:owner']) {\n      let owner = {};\n      if (channel['itunes:owner'][0]['itunes:name']) {\n        owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n      }\n      if (channel['itunes:owner'][0]['itunes:email']) {\n        owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n      }\n      feed.itunes.owner = owner;\n    }\n    if (channel['itunes:image']) {\n      let image;\n      let hasImageHref = channel['itunes:image'][0] && channel['itunes:image'][0].$ && channel['itunes:image'][0].$.href;\n      image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n      if (image) {\n        feed.itunes.image = image;\n      }\n    }\n    if (channel['itunes:category']) {\n      const categoriesWithSubs = channel['itunes:category'].map(category => {\n        return {\n          name: category && category.$ && category.$.text,\n          subs: category['itunes:category'] ? category['itunes:category'].map(subcategory => ({\n            name: subcategory && subcategory.$ && subcategory.$.text\n          })) : null\n        };\n      });\n      feed.itunes.categories = categoriesWithSubs.map(category => category.name);\n      feed.itunes.categoriesWithSubs = categoriesWithSubs;\n    }\n    if (channel['itunes:keywords']) {\n      if (channel['itunes:keywords'].length > 1) {\n        feed.itunes.keywords = channel['itunes:keywords'].map(keyword => keyword && keyword.$ && keyword.$.text);\n      } else {\n        let keywords = channel['itunes:keywords'][0];\n        if (keywords && typeof keywords._ === 'string') {\n          keywords = keywords._;\n        }\n        if (keywords && keywords.$ && keywords.$.text) {\n          feed.itunes.keywords = keywords.$.text.split(',');\n        } else if (typeof keywords === \"string\") {\n          feed.itunes.keywords = keywords.split(',');\n        }\n      }\n    }\n    utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n    items.forEach((item, index) => {\n      let entry = feed.items[index];\n      entry.itunes = {};\n      utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n      let image = item['itunes:image'];\n      if (image && image[0] && image[0].$ && image[0].$.href) {\n        entry.itunes.image = image[0].$.href;\n      }\n    });\n  }\n  setISODate(item) {\n    let date = item.pubDate || item.date;\n    if (date) {\n      try {\n        item.isoDate = new Date(date.trim()).toISOString();\n      } catch (e) {\n        // Ignore bad date format\n      }\n    }\n  }\n\n  /**\n   * Generates a pagination object where the rel attribute is the key and href attribute is the value\n   *  { self: 'self-url', first: 'first-url', ...  }\n   *\n   * @access private\n   * @param {Object} channel parsed XML\n   * @returns {Object}\n   */\n  generatePaginationLinks(channel) {\n    if (!channel['atom:link']) {\n      return {};\n    }\n    const paginationRelAttributes = ['self', 'first', 'next', 'prev', 'last'];\n    return channel['atom:link'].reduce((paginationLinks, link) => {\n      if (!link.$ || !paginationRelAttributes.includes(link.$.rel)) {\n        return paginationLinks;\n      }\n      paginationLinks[link.$.rel] = link.$.href;\n      return paginationLinks;\n    }, {});\n  }\n}\nmodule.exports = Parser;","map":{"version":3,"names":["require","http","https","xml2js","url","fields","utils","DEFAULT_HEADERS","DEFAULT_MAX_REDIRECTS","DEFAULT_TIMEOUT","Parser","constructor","options","headers","customFields","item","feed","requestOptions","maxRedirects","timeout","xmlParser","parseString","xml","callback","prom","Promise","resolve","reject","err","result","Error","buildAtomFeed","rss","$","version","match","buildRSS2","buildRSS1","buildRSS0_9","defaultRSS","maybePromisify","parseURL","feedUrl","redirectCount","get","indexOf","urlParts","parse","Object","assign","requestOpts","req","res","statusCode","newLocation","then","encoding","getEncodingFromContentType","setEncoding","on","chunk","setTimeout","data","clearTimeout","e","xmlObj","items","copyFromXML","link","getLink","title","_","updated","lastBuildDate","entry","map","parseItemAtom","length","published","pubDate","Date","toISOString","author","name","content","getContent","contentSnippet","getSnippet","summary","id","setISODate","channel","buildRSS","decorateItunes","feedFields","concat","itemFields","href","image","width","height","paginationLinks","generatePaginationLinks","keys","xmlItem","parseItemRss","enclosure","description","guid","category","categories","itunes","owner","email","hasImageHref","categoriesWithSubs","text","subs","subcategory","keywords","keyword","split","podcastFeed","forEach","index","podcastItem","date","isoDate","trim","paginationRelAttributes","reduce","includes","rel","module","exports"],"sources":["/home/bing/Git/quantum_news/node_modules/rss-parser/lib/parser.js"],"sourcesContent":["\"use strict\";\nconst http = require('http');\nconst https = require('https');\nconst xml2js = require('xml2js');\nconst url = require('url');\n\nconst fields = require('./fields');\nconst utils = require('./utils');\n\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml',\n}\nconst DEFAULT_MAX_REDIRECTS = 5;\nconst DEFAULT_TIMEOUT = 60000;\n\nclass Parser {\n  constructor(options={}) {\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n\n  parseString(xml, callback) {\n    let prom = new Promise((resolve, reject) => {\n      this.xmlParser.parseString(xml, (err, result) => {\n        if (err) return reject(err);\n        if (!result) {\n          return reject(new Error('Unable to parse XML.'));\n        }\n        let feed = null;\n        if (result.feed) {\n          feed = this.buildAtomFeed(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n          feed = this.buildRSS2(result);\n        } else if (result['rdf:RDF']) {\n          feed = this.buildRSS1(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n          feed = this.buildRSS0_9(result);\n        } else if (result.rss && this.options.defaultRSS) {\n          switch(this.options.defaultRSS) {\n            case 0.9:\n              feed = this.buildRSS0_9(result);\n              break;\n            case 1:\n              feed = this.buildRSS1(result);\n              break;\n            case 2:\n              feed = this.buildRSS2(result);\n              break;\n            default:\n              return reject(new Error(\"default RSS version not recognized.\"))\n          }\n        } else {\n          return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"))\n        }\n        resolve(feed);\n      });\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  parseURL(feedUrl, callback, redirectCount=0) {\n    let xml = '';\n    let get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n    let urlParts = url.parse(feedUrl);\n    let headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n    let timeout = null;\n    let prom = new Promise((resolve, reject) => {\n      const requestOpts = Object.assign({headers}, urlParts, this.options.requestOptions);\n      let req = get(requestOpts, (res) => {\n        if (this.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n          if (redirectCount === this.options.maxRedirects) {\n            return reject(new Error(\"Too many redirects\"));\n          } else {\n            const newLocation = url.resolve(feedUrl, res.headers['location']);\n            return this.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n          }\n        } else if (res.statusCode >= 300) {\n          return reject(new Error(\"Status code \" + res.statusCode))\n        }\n        let encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n        res.setEncoding(encoding);\n        res.on('data', (chunk) => {\n          xml += chunk;\n        });\n        res.on('end', () => {\n          return this.parseString(xml).then(resolve, reject);\n        });\n      })\n      req.on('error', reject);\n      timeout = setTimeout(() => {\n        return reject(new Error(\"Request timed out after \" + this.options.timeout + \"ms\"));\n      }, this.options.timeout);\n    }).then(data => {\n      clearTimeout(timeout);\n      return Promise.resolve(data);\n    }, e => {\n      clearTimeout(timeout);\n      return Promise.reject(e);\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  buildAtomFeed(xmlObj) {\n    let feed = {items: []};\n    utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n    if (xmlObj.feed.link) {\n      feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n      feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n    }\n    if (xmlObj.feed.title) {\n      let title = xmlObj.feed.title[0] || '';\n      if (title._) title = title._\n      if (title) feed.title = title;\n    }\n    if (xmlObj.feed.updated) {\n      feed.lastBuildDate = xmlObj.feed.updated[0];\n    }\n    feed.items = (xmlObj.feed.entry || []).map(entry => this.parseItemAtom(entry));\n    return feed;\n  }\n\n  parseItemAtom(entry) {\n    let item = {};\n    utils.copyFromXML(entry, item, this.options.customFields.item);\n    if (entry.title) {\n      let title = entry.title[0] || '';\n      if (title._) title = title._;\n      if (title) item.title = title;\n    }\n    if (entry.link && entry.link.length) {\n      item.link = utils.getLink(entry.link, 'alternate', 0);\n    }\n    if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n    if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n    if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n    if (entry.content && entry.content.length) {\n      item.content = utils.getContent(entry.content[0]);\n      item.contentSnippet = utils.getSnippet(item.content)\n    }\n    if (entry.summary && entry.summary.length) {\n      item.summary = utils.getContent(entry.summary[0]);\n    }\n    if (entry.id) {\n      item.id = entry.id[0];\n    }\n    this.setISODate(item);\n    return item;\n  }\n\n  buildRSS0_9(xmlObj) {\n    var channel = xmlObj.rss.channel[0];\n    var items = channel.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS1(xmlObj) {\n    xmlObj = xmlObj['rdf:RDF'];\n    let channel = xmlObj.channel[0];\n    let items = xmlObj.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS2(xmlObj) {\n    let channel = xmlObj.rss.channel[0];\n    let items = channel.item;\n    let feed = this.buildRSS(channel, items);\n    if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n      this.decorateItunes(feed, channel);\n    }\n    return feed;\n  }\n\n  buildRSS(channel, items) {\n    items = items || [];\n    let feed = {items: []};\n    let feedFields = fields.feed.concat(this.options.customFields.feed);\n    let itemFields = fields.item.concat(this.options.customFields.item);\n    if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n      feed.feedUrl = channel['atom:link'][0].$.href;\n    }\n    if (channel.image && channel.image[0] && channel.image[0].url) {\n      feed.image = {};\n      let image = channel.image[0];\n      if (image.link) feed.image.link = image.link[0];\n      if (image.url) feed.image.url = image.url[0];\n      if (image.title) feed.image.title = image.title[0];\n      if (image.width) feed.image.width = image.width[0];\n      if (image.height) feed.image.height = image.height[0];\n    }\n    const paginationLinks = this.generatePaginationLinks(channel);\n    if (Object.keys(paginationLinks).length) {\n      feed.paginationLinks = paginationLinks;\n    }\n    utils.copyFromXML(channel, feed, feedFields);\n    feed.items = items.map(xmlItem => this.parseItemRss(xmlItem, itemFields));\n    return feed;\n  }\n\n  parseItemRss(xmlItem, itemFields) {\n    let item = {};\n    utils.copyFromXML(xmlItem, item, itemFields);\n    if (xmlItem.enclosure) {\n      item.enclosure = xmlItem.enclosure[0].$;\n    }\n    if (xmlItem.description) {\n      item.content = utils.getContent(xmlItem.description[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n    if (xmlItem.guid) {\n      item.guid = xmlItem.guid[0];\n      if (item.guid._) item.guid = item.guid._;\n    }\n    if (xmlItem.$ && xmlItem.$['rdf:about']) {\n      item['rdf:about'] = xmlItem.$['rdf:about']\n    }\n    if (xmlItem.category) item.categories = xmlItem.category;\n    this.setISODate(item);\n    return item;\n  }\n\n  /**\n   * Add iTunes specific fields from XML to extracted JSON\n   *\n   * @access public\n   * @param {object} feed extracted\n   * @param {object} channel parsed XML\n   */\n  decorateItunes(feed, channel) {\n    let items = channel.item || [];\n    let categories = [];\n    feed.itunes = {}\n\n    if (channel['itunes:owner']) {\n      let owner = {};\n\n      if(channel['itunes:owner'][0]['itunes:name']) {\n        owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n      }\n      if(channel['itunes:owner'][0]['itunes:email']) {\n        owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n      }\n      feed.itunes.owner = owner;\n    }\n\n    if (channel['itunes:image']) {\n      let image;\n      let hasImageHref = (channel['itunes:image'][0] &&\n        channel['itunes:image'][0].$ &&\n        channel['itunes:image'][0].$.href);\n      image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n      if (image) {\n        feed.itunes.image = image;\n      }\n    }\n\n    if (channel['itunes:category']) {\n      const categoriesWithSubs = channel['itunes:category'].map((category) => {\n        return {\n          name: category && category.$ && category.$.text,\n          subs: category['itunes:category'] ?\n            category['itunes:category']\n              .map((subcategory) => ({\n                name: subcategory && subcategory.$ && subcategory.$.text\n              })) : null,\n        };\n      });\n\n      feed.itunes.categories = categoriesWithSubs.map((category) => category.name);\n      feed.itunes.categoriesWithSubs = categoriesWithSubs;\n    }\n\n    if (channel['itunes:keywords']) {\n      if (channel['itunes:keywords'].length > 1) {\n        feed.itunes.keywords = channel['itunes:keywords'].map(\n          keyword => keyword && keyword.$ && keyword.$.text\n        );\n      } else {\n        let keywords = channel['itunes:keywords'][0];\n        if (keywords && typeof keywords._ === 'string') {\n          keywords = keywords._;\n        }\n\n        if (keywords && keywords.$ && keywords.$.text) {\n          feed.itunes.keywords = keywords.$.text.split(',')\n        } else if (typeof keywords === \"string\") {\n          feed.itunes.keywords = keywords.split(',');\n        }\n      }\n    }\n\n    utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n    items.forEach((item, index) => {\n      let entry = feed.items[index];\n      entry.itunes = {};\n      utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n      let image = item['itunes:image'];\n      if (image && image[0] && image[0].$ && image[0].$.href) {\n        entry.itunes.image = image[0].$.href;\n      }\n    });\n  }\n\n  setISODate(item) {\n    let date = item.pubDate || item.date;\n    if (date) {\n      try {\n        item.isoDate = new Date(date.trim()).toISOString();\n      } catch (e) {\n        // Ignore bad date format\n      }\n    }\n  }\n\n  /**\n   * Generates a pagination object where the rel attribute is the key and href attribute is the value\n   *  { self: 'self-url', first: 'first-url', ...  }\n   *\n   * @access private\n   * @param {Object} channel parsed XML\n   * @returns {Object}\n   */\n  generatePaginationLinks(channel) {\n    if (!channel['atom:link']) {\n      return {};\n    }\n    const paginationRelAttributes = ['self', 'first', 'next', 'prev', 'last'];\n\n    return channel['atom:link'].reduce((paginationLinks, link) => {\n      if (!link.$ || !paginationRelAttributes.includes(link.$.rel)) {\n        return paginationLinks;\n      }\n      paginationLinks[link.$.rel] = link.$.href;\n      return paginationLinks;\n    }, {});\n  }\n}\n\nmodule.exports = Parser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}